{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nfunction isPortableTextSpan(node) {\n  return node._type === \"span\" && \"text\" in node && typeof node.text === \"string\" && (typeof node.marks === \"undefined\" || Array.isArray(node.marks) && node.marks.every(mark => typeof mark === \"string\"));\n}\n\nfunction isPortableTextBlock(node) {\n  return typeof node._type === \"string\" && node._type[0] !== \"@\" && (!(\"markDefs\" in node) || Array.isArray(node.markDefs) && node.markDefs.every(def => typeof def._key === \"string\")) && \"children\" in node && Array.isArray(node.children) && node.children.every(child => typeof child === \"object\" && \"_type\" in child);\n}\n\nfunction isPortableTextListItemBlock(block) {\n  return isPortableTextBlock(block) && \"listItem\" in block && typeof block.listItem === \"string\" && (typeof block.level === \"undefined\" || typeof block.level === \"number\");\n}\n\nfunction isPortableTextToolkitList(block) {\n  return block._type === \"@list\";\n}\n\nfunction isPortableTextToolkitSpan(span) {\n  return span._type === \"@span\";\n}\n\nfunction isPortableTextToolkitTextNode(node) {\n  return node._type === \"@text\";\n}\n\nconst knownDecorators = [\"strong\", \"em\", \"code\", \"underline\", \"strike-through\"];\n\nfunction sortMarksByOccurences(span, index, blockChildren) {\n  if (!isPortableTextSpan(span) || !span.marks) {\n    return [];\n  }\n\n  if (!span.marks.length) {\n    return [];\n  }\n\n  const marks = span.marks.slice();\n  const occurences = {};\n  marks.forEach(mark => {\n    occurences[mark] = 1;\n\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex];\n\n      if (sibling && isPortableTextSpan(sibling) && Array.isArray(sibling.marks) && sibling.marks.indexOf(mark) !== -1) {\n        occurences[mark]++;\n      } else {\n        break;\n      }\n    }\n  });\n  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB));\n}\n\nfunction sortMarks(occurences, markA, markB) {\n  const aOccurences = occurences[markA];\n  const bOccurences = occurences[markB];\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences;\n  }\n\n  const aKnownPos = knownDecorators.indexOf(markA);\n  const bKnownPos = knownDecorators.indexOf(markB);\n\n  if (aKnownPos !== bKnownPos) {\n    return aKnownPos - bKnownPos;\n  }\n\n  return markA.localeCompare(markB);\n}\n\nfunction buildMarksTree(block) {\n  var _a;\n\n  const {\n    children,\n    markDefs = []\n  } = block;\n\n  if (!children || !children.length) {\n    return [];\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences);\n  const rootNode = {\n    _type: \"@span\",\n    children: [],\n    markType: \"<unknown>\"\n  };\n  let nodeStack = [rootNode];\n\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i];\n\n    if (!span) {\n      continue;\n    }\n\n    const marksNeeded = sortedMarks[i] || [];\n    let pos = 1;\n\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = ((_a = nodeStack[pos]) == null ? void 0 : _a.markKey) || \"\";\n        const index = marksNeeded.indexOf(mark);\n\n        if (index === -1) {\n          break;\n        }\n\n        marksNeeded.splice(index, 1);\n      }\n    }\n\n    nodeStack = nodeStack.slice(0, pos);\n    let currentNode = nodeStack[nodeStack.length - 1];\n\n    if (!currentNode) {\n      continue;\n    }\n\n    for (const markKey of marksNeeded) {\n      const markDef = markDefs.find(def => def._key === markKey);\n      const markType = markDef ? markDef._type : markKey;\n      const node = {\n        _type: \"@span\",\n        _key: span._key,\n        children: [],\n        markDef,\n        markType,\n        markKey\n      };\n      currentNode.children.push(node);\n      nodeStack.push(node);\n      currentNode = node;\n    }\n\n    if (isPortableTextSpan(span)) {\n      const lines = span.text.split(\"\\n\");\n\n      for (let line = lines.length; line-- > 1;) {\n        lines.splice(line, 0, \"\\n\");\n      }\n\n      currentNode.children = currentNode.children.concat(lines.map(text => ({\n        _type: \"@text\",\n        text\n      })));\n    } else {\n      currentNode.children = currentNode.children.concat(span);\n    }\n  }\n\n  return rootNode.children;\n}\n\nfunction nestLists(blocks, mode) {\n  const tree = [];\n  let currentList;\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i];\n\n    if (!block) {\n      continue;\n    }\n\n    if (!isPortableTextListItemBlock(block)) {\n      tree.push(block);\n      currentList = void 0;\n      continue;\n    }\n\n    if (!currentList) {\n      currentList = listFromBlock(block, i, mode);\n      tree.push(currentList);\n      continue;\n    }\n\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block);\n      continue;\n    }\n\n    if ((block.level || 1) > currentList.level) {\n      const newList = listFromBlock(block, i, mode);\n\n      if (mode === \"html\") {\n        const lastListItem = currentList.children[currentList.children.length - 1];\n\n        const newLastChild = __spreadProps(__spreadValues({}, lastListItem), {\n          children: [...lastListItem.children, newList]\n        });\n\n        currentList.children[currentList.children.length - 1] = newLastChild;\n      } else {\n        currentList.children.push(newList);\n      }\n\n      currentList = newList;\n      continue;\n    }\n\n    if ((block.level || 1) < currentList.level) {\n      const matchingBranch = tree[tree.length - 1];\n      const match = matchingBranch && findListMatching(matchingBranch, block);\n\n      if (match) {\n        currentList = match;\n        currentList.children.push(block);\n        continue;\n      }\n\n      currentList = listFromBlock(block, i, mode);\n      tree.push(currentList);\n      continue;\n    }\n\n    if (block.listItem !== currentList.listItem) {\n      const matchingBranch = tree[tree.length - 1];\n      const match = matchingBranch && findListMatching(matchingBranch, {\n        level: block.level || 1\n      });\n\n      if (match && match.listItem === block.listItem) {\n        currentList = match;\n        currentList.children.push(block);\n        continue;\n      } else {\n        currentList = listFromBlock(block, i, mode);\n        tree.push(currentList);\n        continue;\n      }\n    }\n\n    console.warn(\"Unknown state encountered for block\", block);\n    tree.push(block);\n  }\n\n  return tree;\n}\n\nfunction blockMatchesList(block, list) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem;\n}\n\nfunction listFromBlock(block, index, mode) {\n  return {\n    _type: \"@list\",\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block]\n  };\n}\n\nfunction findListMatching(rootNode, matching) {\n  const level = matching.level || 1;\n  const style = matching.listItem || \"normal\";\n  const filterOnType = typeof matching.listItem === \"string\";\n\n  if (isPortableTextToolkitList(rootNode) && (rootNode.level || 1) === level && filterOnType && (rootNode.listItem || \"normal\") === style) {\n    return rootNode;\n  }\n\n  if (!(\"children\" in rootNode)) {\n    return void 0;\n  }\n\n  const node = rootNode.children[rootNode.children.length - 1];\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : void 0;\n}\n\nconst leadingSpace = /^\\s/;\nconst trailingSpace = /^\\s/;\n\nfunction toPlainText(block) {\n  const blocks = Array.isArray(block) ? block : [block];\n  let text = \"\";\n  blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) {\n      return;\n    }\n\n    let pad = false;\n    current.children.forEach(span => {\n      if (isPortableTextSpan(span)) {\n        text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? \" \" : \"\";\n        text += span.text;\n        pad = false;\n      } else {\n        pad = true;\n      }\n    });\n\n    if (index !== blocks.length - 1) {\n      text += \"\\n\\n\";\n    }\n  });\n  return text;\n}\n\nfunction spanToPlainText(span) {\n  let text = \"\";\n  span.children.forEach(current => {\n    if (isPortableTextToolkitTextNode(current)) {\n      text += current.text;\n    } else if (isPortableTextToolkitSpan(current)) {\n      text += spanToPlainText(current);\n    }\n  });\n  return text;\n}\n\nconst LIST_NEST_MODE_HTML = \"html\";\nconst LIST_NEST_MODE_DIRECT = \"direct\";\nexport { LIST_NEST_MODE_DIRECT, LIST_NEST_MODE_HTML, buildMarksTree, isPortableTextBlock, isPortableTextListItemBlock, isPortableTextSpan, isPortableTextToolkitList, isPortableTextToolkitSpan, isPortableTextToolkitTextNode, nestLists, sortMarksByOccurences, spanToPlainText, toPlainText };","map":{"version":3,"mappings":"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","names":["node","_type","text","marks","Array","isArray","every","mark","markDefs","def","_key","children","child","block","isPortableTextBlock","listItem","level","span","knownDecorators","index","blockChildren","isPortableTextSpan","length","slice","occurences","forEach","siblingIndex","sibling","indexOf","sort","markA","markB","sortMarks","aOccurences","bOccurences","aKnownPos","bKnownPos","localeCompare","sortedMarks","map","sortMarksByOccurences","rootNode","markType","nodeStack","i","marksNeeded","pos","markKey","splice","currentNode","markDef","find","push","lines","split","line","concat","blocks","mode","tree","currentList","isPortableTextListItemBlock","listFromBlock","blockMatchesList","newList","lastListItem","newLastChild","__spreadProps","matchingBranch","match","findListMatching","warn","list","matching","style","filterOnType","isPortableTextToolkitList","leadingSpace","trailingSpace","current","pad","test","isPortableTextToolkitTextNode","isPortableTextToolkitSpan","spanToPlainText","LIST_NEST_MODE_HTML","LIST_NEST_MODE_DIRECT"],"sources":["C:\\Users\\joaki\\Documents\\GitHub\\Utvikling-Av-Interaktive-Nettsteder\\sanity-leksjon\\frontend\\node_modules\\@portabletext\\toolkit\\src\\asserters.ts","C:\\Users\\joaki\\Documents\\GitHub\\Utvikling-Av-Interaktive-Nettsteder\\sanity-leksjon\\frontend\\node_modules\\@portabletext\\toolkit\\src\\sortMarksByOccurences.ts","C:\\Users\\joaki\\Documents\\GitHub\\Utvikling-Av-Interaktive-Nettsteder\\sanity-leksjon\\frontend\\node_modules\\@portabletext\\toolkit\\src\\buildMarksTree.ts","C:\\Users\\joaki\\Documents\\GitHub\\Utvikling-Av-Interaktive-Nettsteder\\sanity-leksjon\\frontend\\node_modules\\@portabletext\\toolkit\\src\\nestLists.ts","C:\\Users\\joaki\\Documents\\GitHub\\Utvikling-Av-Interaktive-Nettsteder\\sanity-leksjon\\frontend\\node_modules\\@portabletext\\toolkit\\src\\toPlainText.ts","C:\\Users\\joaki\\Documents\\GitHub\\Utvikling-Av-Interaktive-Nettsteder\\sanity-leksjon\\frontend\\node_modules\\@portabletext\\toolkit\\src\\spanToPlainText.ts","C:\\Users\\joaki\\Documents\\GitHub\\Utvikling-Av-Interaktive-Nettsteder\\sanity-leksjon\\frontend\\node_modules\\@portabletext\\toolkit\\src\\types.ts"],"sourcesContent":["import type {\r\n  ArbitraryTypedObject,\r\n  PortableTextBlock,\r\n  PortableTextListItemBlock,\r\n  PortableTextSpan,\r\n  TypedObject,\r\n} from '@portabletext/types'\r\nimport type {ToolkitNestedPortableTextSpan, ToolkitPortableTextList, ToolkitTextNode} from './types'\r\n\r\n/**\r\n * Strict check to determine if node is a correctly formatted Portable Text span.\r\n *\r\n * @param node - Node to check\r\n * @returns True if valid Portable Text span, otherwise false\r\n */\r\nexport function isPortableTextSpan(\r\n  node: ArbitraryTypedObject | PortableTextSpan\r\n): node is PortableTextSpan {\r\n  return (\r\n    node._type === 'span' &&\r\n    'text' in node &&\r\n    typeof node.text === 'string' &&\r\n    (typeof node.marks === 'undefined' ||\r\n      (Array.isArray(node.marks) && node.marks.every((mark) => typeof mark === 'string')))\r\n  )\r\n}\r\n\r\n/**\r\n * Strict check to determine if node is a correctly formatted Portable Text block.\r\n *\r\n * @param node - Node to check\r\n * @returns True if valid Portable Text block, otherwise false\r\n */\r\nexport function isPortableTextBlock(\r\n  node: PortableTextBlock | TypedObject\r\n): node is PortableTextBlock {\r\n  return (\r\n    // A block doesn't _have_ to be named 'block' - to differentiate between\r\n    // allowed child types and marks, one might name them differently\r\n    typeof node._type === 'string' &&\r\n    // Toolkit-types like nested spans are @-prefixed\r\n    node._type[0] !== '@' &&\r\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\r\n    (!('markDefs' in node) ||\r\n      (Array.isArray(node.markDefs) &&\r\n        // Every mark definition needs to have an `_key` to be mappable in child spans\r\n        node.markDefs.every((def) => typeof def._key === 'string'))) &&\r\n    // `children` is required and needs to be an array\r\n    'children' in node &&\r\n    Array.isArray(node.children) &&\r\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\r\n    node.children.every((child) => typeof child === 'object' && '_type' in child)\r\n  )\r\n}\r\n\r\n/**\r\n * Strict check to determine if node is a correctly formatted portable list item block.\r\n *\r\n * @param node - Node to check\r\n * @returns True if valid Portable Text list item block, otherwise false\r\n */\r\nexport function isPortableTextListItemBlock(\r\n  block: PortableTextBlock | TypedObject\r\n): block is PortableTextListItemBlock {\r\n  return (\r\n    isPortableTextBlock(block) &&\r\n    'listItem' in block &&\r\n    typeof block.listItem === 'string' &&\r\n    (typeof block.level === 'undefined' || typeof block.level === 'number')\r\n  )\r\n}\r\n\r\n/**\r\n * Loose check to determine if block is a toolkit list node.\r\n * Only checks `_type`, assumes correct structure.\r\n *\r\n * @param block - Block to check\r\n * @returns True if toolkit list, otherwise false\r\n */\r\nexport function isPortableTextToolkitList(\r\n  block: TypedObject | ToolkitPortableTextList\r\n): block is ToolkitPortableTextList {\r\n  return block._type === '@list'\r\n}\r\n\r\n/**\r\n * Loose check to determine if span is a toolkit span node.\r\n * Only checks `_type`, assumes correct structure.\r\n *\r\n * @param block - Span to check\r\n * @returns True if toolkit span, otherwise false\r\n */\r\nexport function isPortableTextToolkitSpan(\r\n  span: TypedObject | ToolkitNestedPortableTextSpan\r\n): span is ToolkitNestedPortableTextSpan {\r\n  return span._type === '@span'\r\n}\r\n\r\n/**\r\n * Loose check to determine if node is a toolkit text node.\r\n * Only checks `_type`, assumes correct structure.\r\n *\r\n * @param block - Node to check\r\n * @returns True if toolkit text node, otherwise false\r\n */\r\nexport function isPortableTextToolkitTextNode(\r\n  node: TypedObject | ToolkitTextNode\r\n): node is ToolkitTextNode {\r\n  return node._type === '@text'\r\n}\r\n","import type {PortableTextSpan, TypedObject} from '@portabletext/types'\r\nimport {isPortableTextSpan} from './asserters'\r\n\r\nconst knownDecorators = ['strong', 'em', 'code', 'underline', 'strike-through']\r\n\r\n/**\r\n * Figures out the optimal order of marks, in order to minimize the amount of\r\n * nesting/repeated elements in environments such as HTML. For instance, a naive\r\n * implementation might render something like:\r\n *\r\n * ```html\r\n * <strong>This block contains </strong>\r\n * <strong><a href=\"https://some.url/\">a link</a></strong>\r\n * <strong> and some bolded text</strong>\r\n * ```\r\n *\r\n * ...whereas an optimal order would be:\r\n *\r\n * ```html\r\n * <strong>\r\n *   This block contains <a href=\"https://some.url/\">a link</a> and some bolded text\r\n * </strong>\r\n * ```\r\n *\r\n * This is particularly necessary for cases like links, where you don't want multiple\r\n * individual links for different segments of the link text, even if parts of it are\r\n * bolded/italicized.\r\n *\r\n * This function is meant to be used like: `block.children.map(sortMarksByOccurences)`,\r\n * and is used internally in {@link buildMarksTree | `buildMarksTree()`}.\r\n *\r\n * The marks are sorted in the following order:\r\n *\r\n *  1. Marks that are shared amongst the most adjacent siblings\r\n *  2. Non-default marks (links, custom metadata)\r\n *  3. Decorators (bold, emphasis, code etc), in a predefined, preferred order\r\n *\r\n * @param span - The current span to sort\r\n * @param index - The index of the current span within the block\r\n * @param blockChildren - All children of the block being sorted\r\n * @returns Array of decorators and annotations, sorted by \"most adjacent siblings\"\r\n */\r\nexport function sortMarksByOccurences(\r\n  span: PortableTextSpan | TypedObject,\r\n  index: number,\r\n  blockChildren: (PortableTextSpan | TypedObject)[]\r\n): string[] {\r\n  if (!isPortableTextSpan(span) || !span.marks) {\r\n    return []\r\n  }\r\n\r\n  if (!span.marks.length) {\r\n    return []\r\n  }\r\n\r\n  // Slicing because we'll be sorting with `sort()`, which mutates\r\n  const marks = span.marks.slice()\r\n  const occurences: Record<string, number> = {}\r\n  marks.forEach((mark) => {\r\n    occurences[mark] = 1\r\n\r\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\r\n      const sibling = blockChildren[siblingIndex]\r\n\r\n      if (\r\n        sibling &&\r\n        isPortableTextSpan(sibling) &&\r\n        Array.isArray(sibling.marks) &&\r\n        sibling.marks.indexOf(mark) !== -1\r\n      ) {\r\n        occurences[mark]++\r\n      } else {\r\n        break\r\n      }\r\n    }\r\n  })\r\n\r\n  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB))\r\n}\r\n\r\nfunction sortMarks<U extends string, T extends Record<U, number>>(\r\n  occurences: T,\r\n  markA: U,\r\n  markB: U\r\n): number {\r\n  const aOccurences = occurences[markA]\r\n  const bOccurences = occurences[markB]\r\n\r\n  if (aOccurences !== bOccurences) {\r\n    return bOccurences - aOccurences\r\n  }\r\n\r\n  const aKnownPos = knownDecorators.indexOf(markA)\r\n  const bKnownPos = knownDecorators.indexOf(markB)\r\n\r\n  // Sort known decorators last\r\n  if (aKnownPos !== bKnownPos) {\r\n    return aKnownPos - bKnownPos\r\n  }\r\n\r\n  // Sort other marks simply by key\r\n  return markA.localeCompare(markB)\r\n}\r\n","import type {\r\n  ArbitraryTypedObject,\r\n  PortableTextBlock,\r\n  PortableTextMarkDefinition,\r\n} from '@portabletext/types'\r\nimport type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from './types'\r\nimport {isPortableTextSpan} from './asserters'\r\nimport {sortMarksByOccurences} from './sortMarksByOccurences'\r\n\r\n/**\r\n * Takes a Portable Text block and returns a nested tree of nodes optimized for rendering\r\n * in HTML-like environments where you want marks/annotations to be nested inside of eachother.\r\n * For instance, a naive span-by-span rendering might yield:\r\n *\r\n * ```html\r\n * <strong>This block contains </strong>\r\n * <strong><a href=\"https://some.url/\">a link</a></strong>\r\n * <strong> and some bolded and </strong>\r\n * <em><strong>italicized text</strong></em>\r\n * ```\r\n *\r\n * ...whereas an optimal order would be:\r\n *\r\n * ```html\r\n * <strong>\r\n *   This block contains <a href=\"https://some.url/\">a link</a>\r\n *   and some bolded and <em>italicized text</em>\r\n * </strong>\r\n * ```\r\n *\r\n * Note that since \"native\" Portable Text spans cannot be nested,\r\n * this function returns an array of \"toolkit specific\" types:\r\n * {@link ToolkitTextNode | `@text`} and {@link ToolkitNestedPortableTextSpan | `@span` }.\r\n *\r\n * The toolkit-specific type can hold both types, as well as any arbitrary inline objects,\r\n * creating an actual tree.\r\n *\r\n * @param block - The Portable Text block to create a tree of nodes from\r\n * @returns Array of (potentially) nested spans, text nodes and/or arbitrary inline objects\r\n */\r\nexport function buildMarksTree<M extends PortableTextMarkDefinition = PortableTextMarkDefinition>(\r\n  block: PortableTextBlock<M>\r\n): (ToolkitNestedPortableTextSpan<M> | ToolkitTextNode | ArbitraryTypedObject)[] {\r\n  const {children, markDefs = []} = block\r\n  if (!children || !children.length) {\r\n    return []\r\n  }\r\n\r\n  const sortedMarks = children.map(sortMarksByOccurences)\r\n\r\n  const rootNode: ToolkitNestedPortableTextSpan<M> = {\r\n    _type: '@span',\r\n    children: [],\r\n    markType: '<unknown>',\r\n  }\r\n\r\n  let nodeStack: ToolkitNestedPortableTextSpan<M>[] = [rootNode]\r\n\r\n  for (let i = 0; i < children.length; i++) {\r\n    const span = children[i]\r\n    if (!span) {\r\n      continue\r\n    }\r\n\r\n    const marksNeeded = sortedMarks[i] || []\r\n    let pos = 1\r\n\r\n    // Start at position one. Root is always plain and should never be removed\r\n    if (nodeStack.length > 1) {\r\n      for (pos; pos < nodeStack.length; pos++) {\r\n        const mark = nodeStack[pos]?.markKey || ''\r\n        const index = marksNeeded.indexOf(mark)\r\n\r\n        if (index === -1) {\r\n          break\r\n        }\r\n\r\n        marksNeeded.splice(index, 1)\r\n      }\r\n    }\r\n\r\n    // Keep from beginning to first miss\r\n    nodeStack = nodeStack.slice(0, pos)\r\n\r\n    // Add needed nodes\r\n    let currentNode = nodeStack[nodeStack.length - 1]\r\n    if (!currentNode) {\r\n      continue\r\n    }\r\n\r\n    for (const markKey of marksNeeded) {\r\n      const markDef = markDefs.find((def) => def._key === markKey)\r\n      const markType = markDef ? markDef._type : markKey\r\n      const node: ToolkitNestedPortableTextSpan<M> = {\r\n        _type: '@span',\r\n        _key: span._key,\r\n        children: [],\r\n        markDef,\r\n        markType,\r\n        markKey,\r\n      }\r\n\r\n      currentNode.children.push(node)\r\n      nodeStack.push(node)\r\n      currentNode = node\r\n    }\r\n\r\n    // Split at newlines to make individual line chunks, but keep newline\r\n    // characters as individual elements in the array. We use these characters\r\n    // in the span serializer to trigger hard-break rendering\r\n    if (isPortableTextSpan(span)) {\r\n      const lines = span.text.split('\\n')\r\n      for (let line = lines.length; line-- > 1; ) {\r\n        lines.splice(line, 0, '\\n')\r\n      }\r\n\r\n      currentNode.children = currentNode.children.concat(\r\n        lines.map((text) => ({_type: '@text', text}))\r\n      )\r\n    } else {\r\n      // This is some other inline object, not a text span\r\n      currentNode.children = currentNode.children.concat(span)\r\n    }\r\n  }\r\n\r\n  return rootNode.children\r\n}\r\n","import type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\r\nimport type {\r\n  ToolkitListNestMode,\r\n  ToolkitPortableTextDirectList,\r\n  ToolkitPortableTextHtmlList,\r\n  ToolkitPortableTextList,\r\n  ToolkitPortableTextListItem,\r\n} from './types'\r\nimport {\r\n  isPortableTextListItemBlock,\r\n  isPortableTextSpan,\r\n  isPortableTextToolkitList,\r\n} from './asserters'\r\n\r\nexport type ToolkitNestListsOutputNode<T> =\r\n  | T\r\n  | ToolkitPortableTextHtmlList\r\n  | ToolkitPortableTextDirectList\r\n\r\n/**\r\n * Takes an array of blocks and returns an array of nodes optimized for rendering in HTML-like\r\n * environment, where lists are nested inside of eachother instead of appearing \"flat\" as in\r\n * native Portable Text data structures.\r\n *\r\n * Note that the list node is not a native Portable Text node type, and thus is represented\r\n * using the {@link ToolkitPortableTextList | `@list`} type name (`{_type: '@list'}`).\r\n *\r\n * The nesting can be configured in two modes:\r\n *\r\n * - `direct`: deeper list nodes will appear as a direct child of the parent list\r\n * - `html`, deeper list nodes will appear as a child of the last _list item_ in the parent list\r\n *\r\n * When using `direct`, all list nodes will be of type {@link ToolkitPortableTextDirectList},\r\n * while with `html` they will be of type {@link ToolkitPortableTextHtmlList}\r\n *\r\n * These modes are available as {@link LIST_NEST_MODE_HTML} and {@link LIST_NEST_MODE_DIRECT}.\r\n *\r\n * @param blocks - Array of Portable Text blocks and other arbitrary types\r\n * @param mode - Mode to use for nesting, `direct` or `html`\r\n * @returns Array of potentially nested nodes optimized for rendering\r\n */\r\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\r\n  blocks: T[],\r\n  mode: 'direct'\r\n): (T | ToolkitPortableTextDirectList)[]\r\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\r\n  blocks: T[],\r\n  mode: 'html'\r\n): (T | ToolkitPortableTextHtmlList)[]\r\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\r\n  blocks: T[],\r\n  mode: 'direct' | 'html'\r\n): (T | ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList)[]\r\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\r\n  blocks: T[],\r\n  mode: ToolkitListNestMode\r\n): ToolkitNestListsOutputNode<T>[] {\r\n  const tree: ToolkitNestListsOutputNode<T>[] = []\r\n  let currentList: ToolkitPortableTextList | undefined\r\n\r\n  for (let i = 0; i < blocks.length; i++) {\r\n    const block = blocks[i]\r\n    if (!block) {\r\n      continue\r\n    }\r\n\r\n    if (!isPortableTextListItemBlock(block)) {\r\n      tree.push(block)\r\n      currentList = undefined\r\n      continue\r\n    }\r\n\r\n    // Start of a new list?\r\n    if (!currentList) {\r\n      currentList = listFromBlock(block, i, mode)\r\n      tree.push(currentList)\r\n      continue\r\n    }\r\n\r\n    // New list item within same list?\r\n    if (blockMatchesList(block, currentList)) {\r\n      currentList.children.push(block)\r\n      continue\r\n    }\r\n\r\n    // Different list props, are we going deeper?\r\n    if ((block.level || 1) > currentList.level) {\r\n      const newList = listFromBlock(block, i, mode)\r\n\r\n      if (mode === 'html') {\r\n        // Because HTML is kinda weird, nested lists needs to be nested within list items.\r\n        // So while you would think that we could populate the parent list with a new sub-list,\r\n        // we actually have to target the last list element (child) of the parent.\r\n        // However, at this point we need to be very careful - simply pushing to the list of children\r\n        // will mutate the input, and we don't want to blindly clone the entire tree.\r\n\r\n        // Clone the last child while adding our new list as the last child of it\r\n        const lastListItem = currentList.children[\r\n          currentList.children.length - 1\r\n        ] as ToolkitPortableTextListItem\r\n\r\n        const newLastChild: ToolkitPortableTextListItem = {\r\n          ...lastListItem,\r\n          children: [...lastListItem.children, newList],\r\n        }\r\n\r\n        // Swap the last child\r\n        currentList.children[currentList.children.length - 1] = newLastChild\r\n      } else {\r\n        ;(currentList as ToolkitPortableTextDirectList).children.push(\r\n          newList as ToolkitPortableTextDirectList\r\n        )\r\n      }\r\n\r\n      // Set the newly created, deeper list as the current\r\n      currentList = newList\r\n      continue\r\n    }\r\n\r\n    // Different list props, are we going back up the tree?\r\n    if ((block.level || 1) < currentList.level) {\r\n      // Current list has ended, and we need to hook up with a parent of the same level and type\r\n      const matchingBranch = tree[tree.length - 1]\r\n      const match = matchingBranch && findListMatching(matchingBranch, block)\r\n      if (match) {\r\n        currentList = match\r\n        currentList.children.push(block)\r\n        continue\r\n      }\r\n\r\n      // Similar parent can't be found, assume new list\r\n      currentList = listFromBlock(block, i, mode)\r\n      tree.push(currentList)\r\n      continue\r\n    }\r\n\r\n    // Different list props, different list style?\r\n    if (block.listItem !== currentList.listItem) {\r\n      const matchingBranch = tree[tree.length - 1]\r\n      const match = matchingBranch && findListMatching(matchingBranch, {level: block.level || 1})\r\n      if (match && match.listItem === block.listItem) {\r\n        currentList = match\r\n        currentList.children.push(block)\r\n        continue\r\n      } else {\r\n        currentList = listFromBlock(block, i, mode)\r\n        tree.push(currentList)\r\n        continue\r\n      }\r\n    }\r\n\r\n    // eslint-disable-next-line no-console\r\n    console.warn('Unknown state encountered for block', block)\r\n    tree.push(block)\r\n  }\r\n\r\n  return tree\r\n}\r\n\r\nfunction blockMatchesList(block: PortableTextBlock, list: ToolkitPortableTextList) {\r\n  return (block.level || 1) === list.level && block.listItem === list.listItem\r\n}\r\n\r\nfunction listFromBlock(\r\n  block: PortableTextListItemBlock,\r\n  index: number,\r\n  mode: ToolkitListNestMode\r\n): ToolkitPortableTextList {\r\n  return {\r\n    _type: '@list',\r\n    _key: `${block._key || `${index}`}-parent`,\r\n    mode,\r\n    level: block.level || 1,\r\n    listItem: block.listItem,\r\n    children: [block],\r\n  }\r\n}\r\n\r\nfunction findListMatching<T extends TypedObject | PortableTextBlock>(\r\n  rootNode: T,\r\n  matching: Partial<PortableTextListItemBlock>\r\n): ToolkitPortableTextList | undefined {\r\n  const level = matching.level || 1\r\n  const style = matching.listItem || 'normal'\r\n  const filterOnType = typeof matching.listItem === 'string'\r\n  if (\r\n    isPortableTextToolkitList(rootNode) &&\r\n    (rootNode.level || 1) === level &&\r\n    filterOnType &&\r\n    (rootNode.listItem || 'normal') === style\r\n  ) {\r\n    return rootNode\r\n  }\r\n\r\n  if (!('children' in rootNode)) {\r\n    return undefined\r\n  }\r\n\r\n  const node = rootNode.children[rootNode.children.length - 1]\r\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : undefined\r\n}\r\n","import type {ArbitraryTypedObject, PortableTextBlock} from '@portabletext/types'\r\nimport {isPortableTextBlock, isPortableTextSpan} from './asserters'\r\n\r\nconst leadingSpace = /^\\s/\r\nconst trailingSpace = /^\\s/\r\n\r\n/**\r\n * Takes a Portable Text block (or an array of them) and returns the text value\r\n * of all the Portable Text span nodes. Adds whitespace when encountering inline,\r\n * non-span nodes to ensure text flow is optimal.\r\n *\r\n * Note that this only accounts for regular Portable Text blocks - any text inside\r\n * custom content types are not included in the output.\r\n *\r\n * @param block - Single block or an array of blocks to extract text from\r\n * @returns The plain-text content of the blocks\r\n */\r\nexport function toPlainText(\r\n  block: PortableTextBlock | ArbitraryTypedObject[] | PortableTextBlock[]\r\n): string {\r\n  const blocks = Array.isArray(block) ? block : [block]\r\n  let text = ''\r\n\r\n  blocks.forEach((current, index) => {\r\n    if (!isPortableTextBlock(current)) {\r\n      return\r\n    }\r\n\r\n    let pad = false\r\n    current.children.forEach((span) => {\r\n      if (isPortableTextSpan(span)) {\r\n        // If the previous element was a non-span, and we have no natural whitespace\r\n        // between the previous and the next span, insert it to give the spans some\r\n        // room to breathe. However, don't do so if this is the first span.\r\n        text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? ' ' : ''\r\n        text += span.text\r\n        pad = false\r\n      } else {\r\n        pad = true\r\n      }\r\n    })\r\n\r\n    if (index !== blocks.length - 1) {\r\n      text += '\\n\\n'\r\n    }\r\n  })\r\n\r\n  return text\r\n}\r\n","import type {ToolkitNestedPortableTextSpan} from './types'\r\nimport {isPortableTextToolkitSpan, isPortableTextToolkitTextNode} from './asserters'\r\n\r\n/**\r\n * Returns the plain-text representation of a\r\n * {@link ToolkitNestedPortableTextSpan | toolkit-specific Portable Text span}.\r\n *\r\n * Useful if you have a subset of nested nodes and want the text from just those,\r\n * instead of for the entire Portable Text block.\r\n *\r\n * @param span - Span node to get text from (Portable Text toolkit specific type)\r\n * @returns The plain-text version of the span\r\n */\r\nexport function spanToPlainText(span: ToolkitNestedPortableTextSpan): string {\r\n  let text = ''\r\n  span.children.forEach((current) => {\r\n    if (isPortableTextToolkitTextNode(current)) {\r\n      text += current.text\r\n    } else if (isPortableTextToolkitSpan(current)) {\r\n      text += spanToPlainText(current)\r\n    }\r\n  })\r\n  return text\r\n}\r\n","import type {\r\n  ArbitraryTypedObject,\r\n  PortableTextListItemBlock,\r\n  PortableTextMarkDefinition,\r\n  PortableTextSpan,\r\n} from '@portabletext/types'\r\n\r\n/**\r\n * List nesting mode for HTML, see the {@link nestLists | `nestLists()` function}\r\n */\r\nexport const LIST_NEST_MODE_HTML = 'html'\r\n\r\n/**\r\n * List nesting mode for direct, nested lists, see the {@link nestLists | `nestLists()` function}\r\n */\r\nexport const LIST_NEST_MODE_DIRECT = 'direct'\r\n\r\n/**\r\n * List nesting mode, see the {@link nestLists | `nestLists()` function}\r\n */\r\nexport type ToolkitListNestMode = 'html' | 'direct'\r\n\r\n/**\r\n * Toolkit-specific type representing a nested list\r\n *\r\n * See the {@link nestLists | `nestLists()`` function} for more info\r\n */\r\nexport type ToolkitPortableTextList = ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList\r\n\r\n/**\r\n * Toolkit-specific type representing a nested list in HTML mode, where deeper lists are nested\r\n * inside of the _list items_, eg `<ul><li>Some text<ul><li>Deeper</li></ul></li></ul>`\r\n */\r\nexport interface ToolkitPortableTextHtmlList {\r\n  /**\r\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\r\n   */\r\n  _type: '@list'\r\n\r\n  /**\r\n   * Unique key for this list (within its parent)\r\n   */\r\n  _key: string\r\n\r\n  /**\r\n   * List mode, signaling that list nodes will appear as children of the _list items_\r\n   */\r\n  mode: 'html'\r\n\r\n  /**\r\n   * Level/depth of this list node (starts at `1`)\r\n   */\r\n  level: number\r\n\r\n  /**\r\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\r\n   */\r\n  listItem: string\r\n\r\n  /**\r\n   * Child nodes of this list - toolkit-specific list items which can themselves hold deeper lists\r\n   */\r\n  children: ToolkitPortableTextListItem[]\r\n}\r\n\r\n/**\r\n * Toolkit-specific type representing a nested list in \"direct\" mode, where deeper lists are nested\r\n * inside of the lists children, alongside other blocks.\r\n */\r\nexport interface ToolkitPortableTextDirectList {\r\n  /**\r\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\r\n   */\r\n  _type: '@list'\r\n\r\n  /**\r\n   * Unique key for this list (within its parent)\r\n   */\r\n  _key: string\r\n\r\n  /**\r\n   * List mode, signaling that list nodes can appear as direct children\r\n   */\r\n  mode: 'direct'\r\n\r\n  /**\r\n   * Level/depth of this list node (starts at `1`)\r\n   */\r\n  level: number\r\n\r\n  /**\r\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\r\n   */\r\n  listItem: string\r\n\r\n  /**\r\n   * Child nodes of this list - either portable text list items, or another, deeper list\r\n   */\r\n  children: (PortableTextListItemBlock | ToolkitPortableTextDirectList)[]\r\n}\r\n\r\n/**\r\n * Toolkit-specific type representing a list item block, but where the children can be another list\r\n */\r\nexport interface ToolkitPortableTextListItem\r\n  extends PortableTextListItemBlock<\r\n    PortableTextMarkDefinition,\r\n    PortableTextSpan | ToolkitPortableTextList\r\n  > {}\r\n\r\n/**\r\n * Toolkit-specific type representing a text node, used when nesting spans.\r\n *\r\n * See the {@link buildMarksTree | `buildMarksTree()` function}\r\n */\r\nexport interface ToolkitTextNode {\r\n  /**\r\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\r\n   */\r\n  _type: '@text'\r\n\r\n  /**\r\n   * The actual string value of the text node\r\n   */\r\n  text: string\r\n}\r\n\r\n/**\r\n * Toolkit-specific type representing a portable text span that can hold other spans.\r\n * In this type, each span only has a single mark, instead of an array of them.\r\n */\r\nexport interface ToolkitNestedPortableTextSpan<\r\n  M extends PortableTextMarkDefinition = PortableTextMarkDefinition\r\n> {\r\n  /**\r\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\r\n   */\r\n  _type: '@span'\r\n\r\n  /**\r\n   * Unique key for this span\r\n   */\r\n  _key?: string\r\n\r\n  /**\r\n   * Holds the value (definition) of the mark in the case of annotations.\r\n   * `undefined` if the mark is a decorator (strong, em or similar).\r\n   */\r\n  markDef?: M\r\n\r\n  /**\r\n   * The key of the mark definition (in the case of annotations).\r\n   * `undefined` if the mark is a decorator (strong, em or similar).\r\n   */\r\n  markKey?: string\r\n\r\n  /**\r\n   * Type of the mark. For annotations, this is the `_type` property of the value.\r\n   * For decorators, it will hold the name of the decorator (strong, em or similar).\r\n   */\r\n  markType: string\r\n\r\n  /**\r\n   * Child nodes of this span. Can be toolkit-specific text nodes, nested spans\r\n   * or any inline object type.\r\n   */\r\n  children: (\r\n    | ToolkitTextNode\r\n    | ToolkitNestedPortableTextSpan<PortableTextMarkDefinition>\r\n    | ArbitraryTypedObject\r\n  )[]\r\n}\r\n"]},"metadata":{},"sourceType":"module"}